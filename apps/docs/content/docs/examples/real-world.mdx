---
title: Real world example
description: Compose multiple plugins and demonstrate scheduling from jobs/events.
---

This example shows how to:

- Compose `EventPlugin`, `ServerPlugin`, and `SQSPlugin`
- Define jobs and events, and schedule from within handlers
- Run a server worker that polls until the store is exhausted each time cron is invoked

### Code

Based on: `examples/concurrency/index.ts`

```ts
import { Job, Jobbig } from "@jobbig/core";
import { EventPlugin, ServerPlugin, SQSPlugin } from "@jobbig/core/plugins";
import { DrizzleStore } from "@jobbig/drizzle";
import { z } from "zod";

const store = DrizzleStore({ db: db });
const jobbig = Jobbig({ store, jobs: [ /* ... */ ] })
  .use(EventPlugin({
    events: [{
      type: "user.updated",
      schema: z.object({ 
        id: z.string(),
        email: z.email(),
        name: z.string().min(2).max(100)
      })
    }]
  }))
  .use(ServerPlugin())
  .use(SQSPlugin({ queueUrl: "test" }))
  .handle({
    id: "job3",
    schema: z.object({ max: z.number() }),
    handler: async ({ ctx }) => {
      console.log("running job3");
    }
  })
  .event({
    type: "user.created",
    schema: z.object({ 
      id: z.string(),
      email: z.email(),
      name: z.string().min(2).max(100)
    }),
  })
  .on({
    types: ["user.created", "user.updated"],
    handler: async ({ ctx }) => {
      if (ctx.id === "user.updated") {
        console.log("User updated:", ctx.data.email);
      }
      ctx.schedule({ jobId: "job3", data: { max: 10 } });
    },
  });

// Publish events
await jobbig.publish({ 
  type: "user.created", 
  payload: { id: "123", email: "user@example.com", name: "John Doe" } 
});

// in jobbig.ts. deploy these to a cron lambda handler and a lambda regular handler to be triggered by an SQS. 
export const { cron, handler } = jobbig
```



